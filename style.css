// script.js (ES module)
// Ishlash uchun: index.html ga <script type="module" src="script.js"></script> qo'yilgan bo'lishi kerak.

import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';
import { OrbitControls } from 'https://unpkg.com/three@0.152.2/examples/jsm/controls/OrbitControls.js';

// --- Global helpers ---
const canvas = document.getElementById('scene');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(canvas.clientWidth || window.innerWidth, canvas.clientHeight || 520, false);
renderer.outputColorSpace = THREE.SRGBColorSpace;

// Scene & Camera
const scene = new THREE.Scene();

// subtle environment color
scene.background = new THREE.Color(0x071424);

// Camera
const camera = new THREE.PerspectiveCamera(40, canvas.clientWidth / canvas.clientHeight, 0.1, 100);
camera.position.set(0, 1.2, 6);

// Lights
const hemi = new THREE.HemisphereLight(0xbfefff, 0x080820, 0.7);
scene.add(hemi);

const dir = new THREE.DirectionalLight(0xffffff, 1.0);
dir.position.set(5, 10, 7);
dir.castShadow = true;
scene.add(dir);

// Ambient subtle
scene.add(new THREE.AmbientLight(0xffffff, 0.12));

// Controls (subtle, auto-rotate disabled but enable user rotate on desktop)
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.enablePan = false;
controls.maxPolarAngle = Math.PI / 2.1;
controls.minDistance = 2.2;
controls.maxDistance = 12;
controls.target.set(0, 0.5, 0);
controls.update();

// Performance: fewer objects on small screens
const isMobile = window.innerWidth < 800;

// --- Materials palette ---
const matAccent = new THREE.MeshPhysicalMaterial({
  color: 0xffffff,
  metalness: 0.2,
  roughness: 0.25,
  clearcoat: 0.6,
  clearcoatRoughness: 0.1,
  emissive: new THREE.Color(0x7ce7ff).multiplyScalar(0.08)
});

const matGlass = new THREE.MeshPhysicalMaterial({
  color: 0x081526,
  metalness: 0.0,
  roughness: 0.05,
  transmission: 0.75,
  transparent: true,
  opacity: 0.95,
  clearcoat: 0.2
});

// Group: center composition
const group = new THREE.Group();
scene.add(group);

// Create a focal "logo-like" geometry: rounded torus + knot + orbiting spheres
const torus = new THREE.Mesh(
  new THREE.TorusGeometry(1.2, 0.22, 64, 160),
  matAccent
);
torus.rotation.x = -0.45;
torus.position.set(0, 0.6, 0);
group.add(torus);

// inner knot (adds complexity)
const knot = new THREE.Mesh(
  new THREE.TorusKnotGeometry(0.6, 0.18, 160, 32, 2, 3),
  matGlass
);
knot.position.set(0, 0.6, 0);
group.add(knot);

// floating small shapes (spheres and boxes)
const floating = new THREE.Group();
group.add(floating);

const sphereGeo = new THREE.SphereGeometry(0.12, 32, 24);
const boxGeo = new THREE.BoxGeometry(0.22, 0.22, 0.22);

const accentColor = new THREE.Color(0x7ce7ff);
const accent2 = new THREE.Color(0x8a7cff);

// create several orbiting elements
const itemsCount = isMobile ? 6 : 12;
for (let i = 0; i < itemsCount; i++) {
  const geo = (i % 3 === 0) ? boxGeo : sphereGeo;
  const colorMix = accentColor.clone().lerp(accent2, (i / itemsCount));
  const mat = new THREE.MeshPhysicalMaterial({
    color: colorMix,
    metalness: 0.3,
    roughness: 0.2,
    emissive: colorMix.clone().multiplyScalar(0.15)
  });
  const mesh = new THREE.Mesh(geo, mat);
  const radius = 1.8 + Math.random() * 1.6;
  mesh.userData = {
    radius,
    speed: 0.2 + Math.random() * 0.7,
    phase: Math.random() * Math.PI * 2,
    tilt: (Math.random() - 0.5) * 0.8
  };
  floating.add(mesh);
}

// subtle ground glow using a circle mesh
const circleGeo = new THREE.CircleGeometry(3.8, 64);
const circleMat = new THREE.MeshBasicMaterial({ color: 0x04202b, transparent: true, opacity: 0.7 });
const ground = new THREE.Mesh(circleGeo, circleMat);
ground.rotation.x = -Math.PI / 2;
ground.position.y = -0.5;
scene.add(ground);

// Responsive resizing helper
function resizeRendererToDisplaySize() {
  const width = canvas.clientWidth || canvas.parentElement.clientWidth;
  const height = canvas.clientHeight || canvas.parentElement.clientHeight;

  const needResize = canvas.width !== Math.floor(width * renderer.getPixelRatio()) ||
                     canvas.height !== Math.floor(height * renderer.getPixelRatio());

  if (needResize) {
    renderer.setSize(width, height, false);
    camera.aspect = width / height;
    camera.updateProjectionMatrix();
  }
  return needResize;
}

// Mouse parallax
let mouseX = 0, mouseY = 0;
document.addEventListener('pointermove', (e) => {
  const rect = renderer.domElement.getBoundingClientRect();
  const x = (e.clientX - rect.left) / rect.width;
  const y = (e.clientY - rect.top) / rect.height;
  mouseX = (x - 0.5) * 2; // -1..1
  mouseY = (y - 0.5) * 2;
});

// Animation loop
const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);

  const t = clock.getElapsedTime();

  // rotate center group slowly
  group.rotation.y = Math.sin(t * 0.12) * 0.12;

  // animate knot and torus subtle rotation
  knot.rotation.y = t * 0.2;
  knot.rotation.x = Math.sin(t * 0.15) * 0.12;
  torus.rotation.z = Math.sin(t * 0.07) * 0.05;

  // orbit floating items
  floating.children.forEach((m, idx) => {
    const ud = m.userData;
    const angle = t * ud.speed + ud.phase;
    m.position.x = Math.cos(angle) * ud.radius;
    m.position.z = Math.sin(angle) * ud.radius * Math.cos(ud.tilt);
    m.position.y = Math.sin(angle * 0.8 + ud.phase) * 0.6 + 0.6;
    m.rotation.x += 0.01 + idx * 0.001;
    m.rotation.y += 0.007 + idx * 0.001;
  });

  // smooth camera parallax based on mouse
  const camTargetX = mouseX * 0.8;
  const camTargetY = -mouseY * 0.6 + 0.3;
  camera.position.x += (camTargetX - camera.position.x) * 0.04;
  camera.position.y += (camTargetY - camera.position.y) * 0.04;
  camera.lookAt(0, 0.6, 0);

  // controls damping
  controls.update();

  // adaptive pixel ratio: reduce on mobile for perf
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1.2 : 2));

  resizeRendererToDisplaySize();
  renderer.render(scene, camera);
}

animate();

// Accessibility: pause animation if tab not visible to save battery
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    renderer.setAnimationLoop(null);
  } else {
    // restart if needed
    animate();
  }
});

// handle resize for CSS-driven canvas sizing
window.addEventListener('resize', () => {
  resizeRendererToDisplaySize();
});

// Fill footer year
document.getElementById('year').textContent = new Date().getFullYear();
